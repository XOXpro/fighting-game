<!DOCTYPE html>
<!-- Свали последната версия от:	  https://github.com/StanislavNikolov/gamedev_pishtov -->
<!-- Download the latest verion from: https://github.com/StanislavNikolov/gamedev_pishtov -->
<html>
<head>
	<style>
		body, canvas {
			margin: 0;
			padding: 0;
			overflow: hidden;
		}
	</style>
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
	<meta charset="UTF-8"></meta> <!-- allows for cyrillic and other exotic text in console.logs -->
</head>
	<body  onload="init()">
		<canvas id="canvas-id" width="800" height="600">
		<script>
			function areColliding(Ax, Ay, Awidth, Aheight, Bx, By, Bwidth, Bheight) {
				if (Bx <= Ax + Awidth) {
					if (Ax <= Bx + Bwidth) {
						if (By <= Ay + Aheight) {
							if (Ay <= By + Bheight) {
								return 1;
							}
						}
					}
				}
				return 0;
			};

			function randomInteger(upTo){
				return Math.floor(Math.random()*upTo);
			}
function drawlineparalelepiped(rx,ry,rz,sx,sy,sz){
    context.beginPath();
    context.moveTo(rx/rz+400,ry/rz+300)
    context.lineTo((rx+sx)/rz+400,ry/rz+300)
    context.lineTo((rx+sx)/rz+400,(ry+sy)/rz+300)
    context.lineTo(rx/rz+400,(ry+sy)/rz+300)
    context.lineTo(rx/rz+400,ry/rz+300)
    //context.fill();
    context.stroke();
    context.beginPath();
    context.moveTo(rx/(rz+sz)+400,ry/(rz+sz)+300)
    context.lineTo((rx+sx)/(rz+sz)+400,ry/(rz+sz)+300)
    context.lineTo((rx+sx)/(rz+sz)+400,(ry+sy)/(rz+sz)+300)
    context.lineTo(rx/(rz+sz)+400,(ry+sy)/(rz+sz)+300)
    context.lineTo(rx/(rz+sz)+400,ry/(rz+sz)+300)
    //context.fill();
    context.stroke();
    context.beginPath();
    context.moveTo(rx/rz+400,ry/rz+300)
    context.lineTo(rx/(rz+sz)+400,ry/(rz+sz)+300)
    context.lineTo((rx+sx)/(rz+sz)+400,ry/(rz+sz)+300)
    context.lineTo((rx+sx)/rz+400,ry/rz+300)
    context.lineTo(rx/rz+400,ry/rz+300)
    //context.fill();
    context.stroke();
    context.beginPath();
    context.moveTo(rx/rz+400,ry/rz+300)
    context.lineTo(rx/(rz+sz)+400,ry/(rz+sz)+300)
    context.lineTo(rx/(rz+sz)+400,(ry+sy)/(rz+sz)+300)
    context.lineTo(rx/rz+400,(ry+sy)/rz+300)
    context.lineTo(rx/rz+400,ry/rz+300)
    //context.fill();
    context.stroke();
    context.beginPath();
    context.moveTo(rx/rz+400,(ry+sy)/rz+300)
    context.lineTo(rx/(rz+sz)+400,(ry+sy)/(rz+sz)+300)
    context.lineTo((rx+sx)/(rz+sz)+400,(ry+sy)/(rz+sz)+300)
    context.lineTo((rx+sx)/rz+400,(ry+sy)/rz+300)
    context.lineTo(rx/rz+400,(ry+sy)/rz+300)
    //context.fill();
    context.stroke();
    context.beginPath();
    context.moveTo((rx+sx)/rz+400,ry/rz+300)
    context.lineTo((rx+sx)/(rz+sz)+400,ry/(rz+sz)+300)
    context.lineTo((rx+sx)/(rz+sz)+400,(ry+sy)/(rz+sz)+300)
    context.lineTo((rx+sx)/rz+400,(ry+sy)/rz+300)
    context.lineTo((rx+sx)/rz+400,ry/rz+300)
    //context.fill();
    context.stroke();

}
function drawparalelepiped(rx,ry,rz,sx,sy,sz){
    context.beginPath();
    context.moveTo(rx/(rz+sz)+400,ry/(rz+sz)+300)
    context.lineTo((rx+sx)/(rz+sz)+400,ry/(rz+sz)+300)
    context.lineTo((rx+sx)/(rz+sz)+400,(ry+sy)/(rz+sz)+300)
    context.lineTo(rx/(rz+sz)+400,(ry+sy)/(rz+sz)+300)
    context.lineTo(rx/(rz+sz)+400,ry/(rz+sz)+300)
    context.fill();
    context.stroke();
    
    //bottom
    context.beginPath();
    context.moveTo(rx/rz+400,(ry+sy)/rz+300)
    context.lineTo(rx/(rz+sz)+400,(ry+sy)/(rz+sz)+300)
    context.lineTo((rx+sx)/(rz+sz)+400,(ry+sy)/(rz+sz)+300)
    context.lineTo((rx+sx)/rz+400,(ry+sy)/rz+300)
    context.lineTo(rx/rz+400,(ry+sy)/rz+300)
    context.fill();
    //context.stroke();
    
    //context.lineWidth=10
    //top
    context.beginPath();
    context.moveTo(rx/rz+400,ry/rz+300)
    context.lineTo(rx/(rz+sz)+400,ry/(rz+sz)+300)
    context.lineTo((rx+sx)/(rz+sz)+400,ry/(rz+sz)+300)
    context.lineTo((rx+sx)/rz+400,ry/rz+300)
    context.lineTo(rx/rz+400,ry/rz+300)
    context.fill();
    //context.stroke();
    
    //right
    context.beginPath();
    context.moveTo((rx+sx)/rz+400,ry/rz+300)
    context.lineTo((rx+sx)/(rz+sz)+400,ry/(rz+sz)+300)
    context.lineTo((rx+sx)/(rz+sz)+400,(ry+sy)/(rz+sz)+300)
    context.lineTo((rx+sx)/rz+400,(ry+sy)/rz+300)
    context.lineTo((rx+sx)/rz+400,ry/rz+300)
    context.fill();
    //context.stroke();
    
    //left
    context.beginPath();
    context.moveTo(rx/rz+400,ry/rz+300)
    context.lineTo(rx/(rz+sz)+400,ry/(rz+sz)+300)
    context.lineTo(rx/(rz+sz)+400,(ry+sy)/(rz+sz)+300)
    context.lineTo(rx/rz+400,(ry+sy)/rz+300)
    context.lineTo(rx/rz+400,ry/rz+300)
    context.fill();
    //context.stroke();
    
    //front
    context.beginPath();
    context.moveTo(rx/rz+400,ry/rz+300)
    context.lineTo((rx+sx)/rz+400,ry/rz+300)
    context.lineTo((rx+sx)/rz+400,(ry+sy)/rz+300)
    context.lineTo(rx/rz+400,(ry+sy)/rz+300)
    context.lineTo(rx/rz+400,ry/rz+300)
    context.fill();
    //context.stroke();

}
function drawcubetop(rx,ry,rz,rs,db){
    context.stroke();
    context.beginPath();
    context.moveTo(rx/rz+400,ry/rz+300)
    context.lineTo(rx/(rz+db)+400,ry/(rz+db)+300)
    context.lineTo((rx+rs)/(rz+db)+400,ry/(rz+db)+300)
    context.lineTo((rx+rs)/rz+400,ry/rz+300)
    context.lineTo(rx/rz+400,ry/rz+300)
    context.fill();
    context.stroke();
}
function drawlinecubetop(rx,ry,rz,rs,db){
    context.stroke();
    context.beginPath();
    context.moveTo(rx/rz+400,ry/rz+300)
    context.lineTo(rx/(rz+db)+400,ry/(rz+db)+300)
    context.lineTo((rx+rs)/(rz+db)+400,ry/(rz+db)+300)
    context.lineTo((rx+rs)/rz+400,ry/rz+300)
    context.lineTo(rx/rz+400,ry/rz+300)
    //context.fill();
    context.stroke();
}
function drawplatform(rx,ry,rz,sx,sy,sz){
    context.beginPath();
    context.moveTo(rx/rz+400,ry/rz+300)
    context.lineTo((rx+sx)/rz+400,ry/rz+300)
    context.lineTo((rx+sx)/rz+400,(ry+sy)/rz+300)
    context.lineTo(rx/rz+400,(ry+sy)/rz+300)
    context.lineTo(rx/rz+400,ry/rz+300)
    //context.fill();
    context.stroke();
    context.beginPath();
    context.moveTo(rx/(rz+sz)+400,ry/(rz+sz)+300)
    context.lineTo((rx+sx)/(rz+sz)+400,ry/(rz+sz)+300)
    context.lineTo((rx+sx)/(rz+sz)+400,(ry+sy)/(rz+sz)+300)
    context.lineTo(rx/(rz+sz)+400,(ry+sy)/(rz+sz)+300)
    context.lineTo(rx/(rz+sz)+400,ry/(rz+sz)+300)
    //context.fill();
    context.stroke();
    context.beginPath();
    context.moveTo(rx/rz+400,ry/rz+300)
    context.lineTo(rx/(rz+sz)+400,ry/(rz+sz)+300)
    context.lineTo(rx/(rz+sz)+400,(ry+sy)/(rz+sz)+300)
    context.lineTo(rx/rz+400,(ry+sy)/rz+300)
    context.lineTo(rx/rz+400,ry/rz+300)
    //context.fill();
    context.stroke();
    context.beginPath();
    context.moveTo(rx/rz+400,(ry+sy)/rz+300)
    context.lineTo(rx/(rz+sz)+400,(ry+sy)/(rz+sz)+300)
    context.lineTo((rx+sx)/(rz+sz)+400,(ry+sy)/(rz+sz)+300)
    context.lineTo((rx+sx)/rz+400,(ry+sy)/rz+300)
    context.lineTo(rx/rz+400,(ry+sy)/rz+300)
    //context.fill();
    context.stroke();
    context.beginPath();
    context.moveTo((rx+sx)/rz+400,ry/rz+300)
    context.lineTo((rx+sx)/(rz+sz)+400,ry/(rz+sz)+300)
    context.lineTo((rx+sx)/(rz+sz)+400,(ry+sy)/(rz+sz)+300)
    context.lineTo((rx+sx)/rz+400,(ry+sy)/rz+300)
    context.lineTo((rx+sx)/rz+400,ry/rz+300)
    //context.fill();
    context.stroke();
    context.beginPath();
    context.moveTo(rx/rz+400,ry/rz+300)
    context.lineTo(rx/(rz+sz)+400,ry/(rz+sz)+300)
    context.lineTo((rx+sx)/(rz+sz)+400,ry/(rz+sz)+300)
    context.lineTo((rx+sx)/rz+400,ry/rz+300)
    context.lineTo(rx/rz+400,ry/rz+300)
    context.fill();
    context.stroke();

}
			function drawLine(startX, startY, endX, endY) {
				// For better performance bunch calls to lineTo without beginPath() and stroke() inbetween.
				context.beginPath(); // resets the current path
				context.moveTo(startX, startY);
				context.lineTo(endX, endY);
				context.stroke();
			}

			function tryToLoad(imageNameWithoutDotPng, backupColor) {
				result={};
				result.img=new Image();
				result.img.src = "images/"+imageNameWithoutDotPng + ".png";
				result.color=backupColor;
				return result;
			}

			function tryToLoadWithFullPath(imageNameAndPath, backupColor) {
				result={};
				result.img=new Image();
				result.img.src = imageNameAndPath;
				result.color=backupColor;
				return result;
			}

			function drawImage(imageWithBackupColorObject, x, y, xs, ys) {
				try {
					if (xs!==undefined){
						context.drawImage(imageWithBackupColorObject.img, x, y, xs, ys);
					} else {
						context.drawImage(imageWithBackupColorObject.img, x, y);
					}
				} catch(e) {
					context.fillStyle = imageWithBackupColorObject.color;
					if (xs == null) {
						xs = 100;
						ys = 100;
					}
					context.fillRect(x, y, xs, ys);
				}
			}
			let p1left             = tryToLoad("p1left","black");
			let p1right            = tryToLoad("p1right","black");
			let p1leftbloody       = tryToLoad("p1leftbloody","black");
			let p1rightbloody      = tryToLoad("p1rightbloody","black");
			let dmg                = tryToLoad("dmg","black");
			let emerald            = tryToLoad("emerald","black");
			let meter              = tryToLoad("meter","black");
			let knife              = tryToLoad("knife","black");
			let knife2             = tryToLoad("knife2","black");
			let p2left             = tryToLoad("p2left","black");
			let p2right            = tryToLoad("p2right","black");
			let p2leftbloody       = tryToLoad("p2leftbloody","black");
			let p2rightbloody      = tryToLoad("p2rightbloody","black");
			let roadroller         = tryToLoad("roadroller","black");
			let explosion1         = tryToLoad("explosion1","black");
			let explosion2         = tryToLoad("explosion2","black");
			let explosion3         = tryToLoad("explosion3","black");
			let sha                = tryToLoad("sha","black");
			let sha2               = tryToLoad("sha2","black");
			let bullet1            = tryToLoad("bullet1","black");
			let bullet2            = tryToLoad("bullet2","black");
			let bullet1a           = tryToLoad("bullet1a","black");
			let bullet2a           = tryToLoad("bullet2a","black");
			let anya               = tryToLoad("anya","black");
			let anya2              = tryToLoad("anya2","black");
			let endlessCanvas = false;
			let updateTime = 10; // in ms
			</script>
			<!-- user's game file -->
			<script src="game.js"></script>
			<script>
			const canvas = document.getElementById("canvas-id");
            if (endlessCanvas) {
                canvas.width = window.innerWidth;
				canvas.height = window.innerHeight;
				window.onresize = function () {
				    canvas.width = window.innerWidth;
					canvas.height = window.innerHeight;
				};
            } else {
				canvas.width = 10000;
				canvas.height = 10000;
            }
			const context = canvas.getContext("2d");
			context.fillStyle = "#0000ff";
            // global variables with mouse coordinates
			let mouseX = 0;
			let mouseY = 0;
            // some keycodes
			let key_left = 37;
			let key_up = 38;
            let key_right = 39;
			let key_down = 40;
			let key_a = 65;
			let key_z = 90;
			let isKeyPressed = [];
			for (i = 0; i < 256; ++i) {
				isKeyPressed.push(0);
			}
			// gridSize = 50; // uncomment or add to game.js if you want a grid
			const reqAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
				setTimeout(callback, 1000 / 30);
			};
			function redraw() {
				context.clearRect(0, 0, canvas.width, canvas.height);
				draw(); // call progammer's draw() function
				context.globalAlpha = 1;
				// draw grid
				//context.fillStyle = "#FF0000";
				context.font = "10px Arial";
				if (typeof gridSize != "undefined" && gridSize >= 25) {
					context.fillText(0, 4, 10);
					context.beginPath();
					for(i = gridSize;i < canvas.width;i += gridSize) {
						context.moveTo(i, 0);
						context.lineTo(i, canvas.height);
						context.fillText(i, i + 4, 10);
					}
					for(i = gridSize;i < canvas.height;i += gridSize) {
						context.moveTo(0, i);
						context.lineTo(canvas.width, i);
						context.fillText(i, 4, i + 10);
					}
					context.stroke();
				}

				reqAnimationFrame(redraw);
			};

			function init() {
				if ('ontouchstart' in window || navigator.maxTouchPoints) {
					isMobile = true;
					window.addEventListener("touchstart", function (e) {
						let touchobj = e.changedTouches[0];
						mouseX = parseInt(touchobj.pageX - canvas.offsetLeft);
						mouseY = parseInt(touchobj.pageY - canvas.offsetTop);
						mousedown();
					});
					window.addEventListener("touchend", function (e) {
						let touchobj = e.changedTouches[0];
						mouseX = parseInt(touchobj.pageX - canvas.offsetLeft);
						mouseY = parseInt(touchobj.pageY - canvas.offsetTop);
						mouseup();
					});
					window.addEventListener("touchmove", function (e) {
						let touchobj = e.changedTouches[0];
						mouseX = parseInt(touchobj.pageX - canvas.offsetLeft);
						mouseY = parseInt(touchobj.pageY - canvas.offsetTop);
					});
				}
				window.addEventListener("mousemove", function (e) {
					mouseX = e.pageX - canvas.offsetLeft;
					mouseY = e.pageY - canvas.offsetTop;
				});
				if(typeof mousemove != "undefined") {
					window.addEventListener("mousemove", mousemove);
				}
				if(typeof mouseup != "undefined") {
					window.addEventListener("mouseup", mouseup);
				}
				if(typeof mousedown != "undefined") {
					window.addEventListener("mousedown", mousedown);
				}
				if(typeof keydown != "undefined") {
					window.addEventListener("keydown", function (e) {
						isKeyPressed[e.keyCode] = 1;
						keydown(e.keyCode);
					});
				} else {
					window.addEventListener("keydown", function (e) {
						isKeyPressed[e.keyCode] = 1;
					});
				}
				if(typeof keyup != "undefined") {
					window.addEventListener("keyup", function (e) {
						isKeyPressed[e.keyCode] = 0;
						keyup(e.keyCode);
					});
				} else {
					window.addEventListener("keyup", function (e) {
						isKeyPressed[e.keyCode] = 0;
					});
				}
				if(typeof draw == "undefined") {
					redraw = function () {
						context.clearRect(0, 0, canvas.width, canvas.height);
						context.globalAlpha = 1;
						context.fillStyle = "#FF0000";
						context.font = "20px Arial";
						context.fillText("Press <F12> for error info!", 40, 40);
					};
				}
				redraw();
				setInterval(update, updateTime);
			}
			</script>
		</canvas>
	</body>
</html>
